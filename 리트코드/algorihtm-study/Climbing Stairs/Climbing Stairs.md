# Review
- 시간 복잡도가 2의 n승 -> 그런데 범위가 45까지 -> Recursion처럼 일일히 해보는건 불가능
- 전형적인 피보나치 수열형 DP
  - 보통 DP는 n개의 값을 선언 후 배열로 해결
  - 하지만, 이 문제처럼 이전의 값을 이용하는 문제는 space complicity로 해결 가능?

## 풀이
- 현재 위치에서 갈 수 있는 것보다 현재 위치까지 올 수 있는 경우를 생각하는게 편함
  - 1) 한 칸 이전에서 오거나
    2) 두 칸 이전에서 오거나
- 결국 각 자리마다 갈 수 있는 경우의 수가 정해져 있음
  - **n = 2일 때의 결과가 n = 3일 때 포함되어 있음**
  - 마찬가지로 n = 3일 때의 결과가 n = 4일 때 포함되어 있음
 
- 결과적으로 **피보나치 수열**
  - n 번째에 도달할 수 있는 결과값 = (n - 1) + (n - 2)
  - f(n) = f(n - 1) + f(n - 2)
 
- 보통 피보나치 수열은 배열로 해결하는데, 어차피 처리할 수가 두 개뿐이므로 space complictcity를 줄일 수 있는 방법이 존재

![image](https://github.com/eunbileeme/algorithm/assets/103405457/0d5e266b-749d-489b-9316-2bbb873d678b)
