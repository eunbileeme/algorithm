# Review
- 어려운 척 하는 이진 탐색 문제
- 첫 값과 마지막 값을 비교했을 때, 끝 값이 첫 값보다 크면 내용이 정렬이 되어 있는 것

## 풀이
- **원본 배열은 정렬되어 있음**
  - 즉, 축을 기준으로 둘(앞 부분, 뒷 부분) 중 **한 군데는 정렬이 되어 있음**

- 정렬된 쪽을 기준으로 내가 찾고자 하는 값이 있을 때는 이진 탐색
  - 아니라면, 내가 찾고자 하는 값이 반대쪽에 있을 수도 없을 수도 있음 -> 결국 직접 순회해봐야

 `if (nums[l] <= nums[m])`
- 가운데 값이 왼쪽보다 크거나 같은 경우 -> 왼쪽 파트가 정렬이 되어 있는 것

  `if (target >= nums[l] && target < nums[m])`
  - 그 사이에 내가 찾고자하는 값이 있는 경우 
 
![image](https://github.com/eunbileeme/algorithm/assets/103405457/c9b77cda-ccde-436b-bbbb-98d68201f95e)

## nums가 중복이 허용되는 경우란?
- 중복이 생기는 경우만 l과 r을 카운트해서 줄여주는 방법으로 해결할 수 있음

### 시간복잡도
- 이론적인 시간 복잡도는 O(n)이지만, 줄인 경우에서는 O(logn)으로 동작

![image](https://github.com/eunbileeme/algorithm/assets/103405457/807358b9-5ef7-4ebc-9b10-e36df88fc21f)


