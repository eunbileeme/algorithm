# Binary Search Tree(이진 탐색 트리)
- 인덱스를 기준으로 앞(L), 뒤(R)를 기준으로 목표 값을 찾아나가는 알고리즘
  - **사전**과 유사한 알고리즘
 
## 예시
![image](https://github.com/eunbileeme/algorithm/assets/103405457/382df4b4-d2f4-4913-b1b3-f79b95b161e1)

### L(2) ~ R(26) 중 15를 찾는다면?

1. (첫 번째 반복) M(12)를 기준으로 15보다 작음 -> 2 ~ 12까지의 범위 값은 필요가 없으므로 L을 12로 옮김..

## 결론
### 시간 복잡도 : O(lonN) (실제로는 log2N이지만, 빅-오 표기법에서 고차항에 속하는 상수는 제외하고 표기하므로 logN)
- 한 번씩 반복을 돌 때마다 봐야하는 범위가 반절씩 줄어듦

### log2N = 10,000,000,000 = 33
- logN이라는 시간 복잡도는 100을 넘기가 어려움 -> O(n)보다 훨씬 빠른 편

### 실제 예시
- DB에서 인덱스를 설정할 때 등등

## 코드
![image](https://github.com/eunbileeme/algorithm/assets/103405457/fe331667-11e8-4e28-86f8-959e88042139)

# 관련 유형
- 조건을 가진 범위 중에서 가장 작은 값 찾기
![image](https://github.com/eunbileeme/algorithm/assets/103405457/ef760c43-f64f-4003-8fd8-0b2851f46f5e)

1. R을 당겨오는 경우 -> 이미 조건을 만족하는 상태에서 범위를 당기므로, M의 위치로 당김
2. L을 당겨오는 경우 -> 조건을 만족하지 않는 상태에서 범위를 당기므로, M + 1의 위치로 당김

결론적으로 L과 R이 겹치는 위치가 **조건을 만족하는 최솟값이 됨**

## 코드
![image](https://github.com/eunbileeme/algorithm/assets/103405457/f0e73c25-4d0d-49c7-b5c0-7692e64a53b1)

# 이진 탐색 트리를 적용하려면?
- 이미 정렬이 되어 있다는 가정이 필요함
- 범위를 알아야 함
- 조건을 만족하는 케이스가 조건을 만족하는 범위내야 존재해야 함

## 추천 학습 방향
- 리트코드에서 **이진 탐색 트리** 태그의 문제들을 풀기
